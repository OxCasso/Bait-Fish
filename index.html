<!DOCTYPE html>
<html>
<head>
    <title>Bait Fish</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto;
            background-color: #87CEEB;
        }
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #333;
            overflow: hidden;
            position: relative;
        }
        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
        }
        #startButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
        #joystick {
            position: absolute;
            right: 15%;
            bottom: 15%;
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
        }
        #joystickKnob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="320" height="480"></canvas>
    <div id="startScreen">
        <h1>Bait Fish</h1>
        <button id="startButton">Start</button>
    </div>
    <div id="joystick">
        <div id="joystickKnob"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const joystick = document.getElementById('joystick');
        const joystickKnob = document.getElementById('joystickKnob');

        // Game objects
        const minnow = {
            x: 160,
            y: 240,
            radius: 10,
            speed: 5,
            floatSpeed: 0.1
        };

        let sunfishList = [];
        let spottedSunfishList = [];
        let garList = [];
        let crabList = [];
        let bassList = [];
        let pikeList = [];
        let bubbles = [];
        let gameOver = false;
        let gameStarted = false;
        let joystickX = 0;
        let joystickY = 0;
        let timeSurvived = 0;
        let score = 0;
        let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;
        const initialDelay = 3 * 60;
        const maxSunfish = 12;
        const maxSpottedSunfish = 1;
        const maxGars = 3;
        const maxBass = 2;
        const maxCrabs = 2;
        const maxPikes = 1;

        const difficultyStages = [
            { time: 0, sunfishInterval: 15 * 60, garInterval: 5, bassInterval: Infinity, crabChance: 0.001, speedMultiplier: 1.0, aggressionRange: 25, aggressionSpeed: 1.5, pikeInterval: Infinity },
            { time: 90 * 60, sunfishInterval: 12 * 60, garInterval: 4, bassInterval: 35 * 60, crabChance: 0.002, speedMultiplier: 1.1, aggressionRange: 30, aggressionSpeed: 2, pikeInterval: 75 * 60 },
            { time: 150 * 60, sunfishInterval: 10 * 60, garInterval: 3, bassInterval: 30 * 60, crabChance: 0.003, speedMultiplier: 1.3, aggressionRange: 35, aggressionSpeed: 2.5, pikeInterval: 70 * 60 },
            { time: 210 * 60, sunfishInterval: 8 * 60, garInterval: 2, bassInterval: 25 * 60, crabChance: 0.004, speedMultiplier: 1.5, aggressionRange: 40, aggressionSpeed: 3, pikeInterval: 65 * 60 },
            { time: 270 * 60, sunfishInterval: 6 * 60, garInterval: 1, bassInterval: 20 * 60, crabChance: 0.005, speedMultiplier: 1.7, aggressionRange: 45, aggressionSpeed: 3.5, pikeInterval: 60 * 60 }
        ];

        function getDifficultyStage() {
            for (let i = difficultyStages.length - 1; i >= 0; i--) {
                if (timeSurvived >= difficultyStages[i].time) return difficultyStages[i];
            }
            return difficultyStages[0];
        }

        let warningActive = false;
        let warningTimer = 0;
        let warningX = 0;
        let warningBlink = 0;

        // Spawn functions
        function spawnSunfish() {
            const size = 20;
            const difficulty = getDifficultyStage();
            const side = Math.random() < 0.5 ? 0 : 1;
            let x = side === 0 ? -size : canvas.width + size;
            let y = Math.random() * (canvas.height - size - 50);
            let speedX = side === 0 ? (Math.random() * 1.5 + 0.5) * difficulty.speedMultiplier : -(Math.random() * 1.5 + 0.5) * difficulty.speedMultiplier;
            let speedY = (Math.random() * 0.5 - 0.25) * difficulty.speedMultiplier;
            return { x, y, width: size, height: size, speedX, speedY, changeDirection: Math.floor(Math.random() * 60) + 60, timeOffScreen: 0 };
        }

        function spawnSpottedSunfish() {
            const size = 20;
            const difficulty = getDifficultyStage();
            const side = Math.random() < 0.5 ? 0 : 1;
            let x = side === 0 ? -size : canvas.width + size;
            let y = Math.random() * (canvas.height - size - 50);
            let speedX = side === 0 ? (Math.random() * 1.7 + 0.8) * difficulty.speedMultiplier : -(Math.random() * 1.7 + 0.8) * difficulty.speedMultiplier;
            let speedY = (Math.random() * 0.5 - 0.25) * difficulty.speedMultiplier;
            return { x, y, width: size, height: size, speedX, speedY, changeDirection: Math.floor(Math.random() * 60) + 30, timeOffScreen: 0 };
        }

        function spawnGar() {
            const width = 80;
            const height = 20;
            const difficulty = getDifficultyStage();
            const side = Math.random() < 0.5 ? 0 : 1;
            let x = side === 0 ? -width : canvas.width + width;
            let y = Math.random() * (canvas.height - 50 - height);
            let speedX = side === 0 ? (Math.random() * 0.8 + 0.2) * difficulty.speedMultiplier : -(Math.random() * 0.8 + 0.2) * difficulty.speedMultiplier;
            let speedY = (Math.random() * 0.4 - 0.2) * difficulty.speedMultiplier;
            return { x, y, width, height, speedX, speedY, changeDirection: Math.floor(Math.random() * 60) + 60 };
        }

        function spawnCrab() {
            const size = 15;
            const side = Math.random() < 0.5 ? 0 : 1;
            let x = side === 0 ? -size : canvas.width + size;
            let y = canvas.height - 50 - size;
            let speedX = side === 0 ? Math.random() * 0.5 + 0.3 : -(Math.random() * 0.5 + 0.3);
            return { x, y, width: size, height: size, speedX };
        }

        function spawnBass() {
            const width = 50;
            const height = 50;
            const difficulty = getDifficultyStage();
            const side = Math.random() < 0.5 ? 0 : 1;
            let x = side === 0 ? -width : canvas.width + width;
            let y = Math.random() * (canvas.height - 50 - height);
            let speedX = side === 0 ? (Math.random() * 1.5 + 0.5) * difficulty.speedMultiplier : -(Math.random() * 1.5 + 0.5) * difficulty.speedMultiplier;
            let speedY = (Math.random() * 0.6 - 0.3) * difficulty.speedMultiplier;
            return { x, y, width, height, speedX, speedY, changeDirection: Math.floor(Math.random() * 60) + 60 };
        }

        function spawnPike() {
            const width = 120;
            const height = 60;
            const difficulty = getDifficultyStage();
            const side = Math.random() < 0.5 ? 0 : 1;
            let x = side === 0 ? -width : canvas.width + width;
            let y = Math.random() * (canvas.height - 50 - height);
            let speedX = side === 0 ? (Math.random() * 1.5 + 1.5) * difficulty.speedMultiplier : -(Math.random() * 1.5 + 1.5) * difficulty.speedMultiplier;
            let speedY = (Math.random() * 0.8 - 0.4) * difficulty.speedMultiplier;
            warningActive = true;
            warningTimer = 360;
            warningX = side === 0 ? 20 : canvas.width - 20;
            warningBlink = 0;
            return { 
                x, 
                y, 
                width, 
                height, 
                speedX, 
                speedY, 
                changeDirection: Math.floor(Math.random() * 60) + 60,
                spawnDelay: 120 
            };
        }

        // Bubble spawning
        function spawnBubble() {
            const radius = Math.random() * 10 + 5;
            return {
                x: Math.random() * canvas.width,
                y: canvas.height + radius,
                radius: radius,
                speedY: -(Math.random() * 0.5 + 0.5)
            };
        }

        // Joystick controls
        let isDragging = false;
        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            updateJoystick(e.touches[0]);
        });
        joystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;
            updateJoystick(e.touches[0]);
        });
        joystick.addEventListener('touchend', () => {
            isDragging = false;
            joystickX = 0;
            joystickY = 0;
            joystickKnob.style.left = '50%';
            joystickKnob.style.top = '50%';
        });

        function updateJoystick(touch) {
            const rect = joystick.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const dx = touchX - centerX;
            const dy = touchY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 30;
            if (distance > maxDistance) {
                const angle = Math.atan2(dy, dx);
                joystickX = Math.cos(angle) * maxDistance;
                joystickY = Math.sin(angle) * maxDistance;
            } else {
                joystickX = dx;
                joystickY = dy;
            }
            joystickKnob.style.left = `${centerX + joystickX}px`;
            joystickKnob.style.top = `${centerY + joystickY}px`;
        }

        // Collision detection
        function checkCollisionCircleRect(circle, rect) {
            const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
            const dx = circle.x - closestX;
            const dy = circle.y - closestY;
            return (dx * dx + dy * dy) < (circle.radius * circle.radius);
        }

        function checkCollisionRectRect(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        // Update game state
        function update() {
            if (!gameStarted || gameOver) return;

            // Move minnow with joystick
            minnow.x += (joystickX / 20) * minnow.speed;
            minnow.y += (joystickY / 40) * minnow.speed;

            if (joystickX === 0 && joystickY === 0) {
                minnow.y += minnow.floatSpeed;
            }

            minnow.x = Math.max(minnow.radius, Math.min(canvas.width - minnow.radius, minnow.x));
            minnow.y = Math.max(minnow.radius, Math.min(canvas.height - 50 - minnow.radius, minnow.y));

            // Update time and spawn enemies
            timeSurvived++;
            const difficulty = getDifficultyStage();

            if (timeSurvived === initialDelay) {
                sunfishList.push(spawnSunfish());
                sunfishList.push(spawnSunfish());
                if (timeSurvived >= 1800) {
                    spottedSunfishList.push(spawnSpottedSunfish());
                }
            } else if (timeSurvived > initialDelay && 
                      (timeSurvived - initialDelay) % difficulty.sunfishInterval === 0 && 
                      (sunfishList.length + spottedSunfishList.length) < maxSunfish) {
                if (Math.random() < 0.2 && spottedSunfishList.length < maxSpottedSunfish && timeSurvived >= 1800) {
                    spottedSunfishList.push(spawnSpottedSunfish());
                } else {
                    sunfishList.push(spawnSunfish());
                }
                if (garList.length < maxGars && (sunfishList.length + spottedSunfishList.length) % difficulty.garInterval === 0) {
                    garList.push(spawnGar());
                }
            }

            if (crabList.length < maxCrabs && Math.random() < difficulty.crabChance) {
                crabList.push(spawnCrab());
            }

            if (difficulty.bassInterval !== Infinity && 
                timeSurvived % difficulty.bassInterval === 0 && 
                bassList.length < maxBass) {
                bassList.push(spawnBass());
            }

            if (difficulty.pikeInterval && 
                timeSurvived % difficulty.pikeInterval === 0 && 
                pikeList.length < maxPikes && 
                timeSurvived >= 60 * 60) {
                const pike = spawnPike();
                pikeList.push(pike);
            }

            // Update warning
            if (warningActive) {
                warningTimer--;
                warningBlink = (warningBlink + 1) % 20;
                if (warningTimer <= 0) warningActive = false;
            }

            // Update pike
            pikeList.forEach((pike, pikeIndex) => {
                if (pike.spawnDelay > 0) {
                    pike.spawnDelay--;
                    return;
                }

                pike.x += pike.speedX;
                pike.y += pike.speedY;
                pike.changeDirection--;
                if (pike.changeDirection <= 0) {
                    pike.speedY = (Math.random() * 0.8 - 0.4) * difficulty.speedMultiplier;
                    pike.changeDirection = Math.floor(Math.random() * 60) + 60;
                }

                pike.y = Math.max(0, Math.min(canvas.height - 50 - pike.height, pike.y));

                const isOffScreen = pike.x + pike.width < 0 || pike.x > canvas.width;
                if (isOffScreen && !warningActive) {
                    pikeList.splice(pikeIndex, 1);
                } else if (checkCollisionCircleRect(minnow, pike)) {
                    gameOver = true;
                }

                sunfishList.forEach((sunfish, sunIndex) => {
                    if (checkCollisionRectRect(pike, sunfish)) {
                        sunfishList.splice(sunIndex, 1);
                    }
                });

                spottedSunfishList.forEach((sunfish, sunIndex) => {
                    if (checkCollisionRectRect(pike, sunfish)) {
                        spottedSunfishList.splice(sunIndex, 1);
                    }
                });

                garList.forEach((gar, garIndex) => {
                    if (checkCollisionRectRect(pike, gar)) {
                        garList.splice(garIndex, 1);
                    }
                });

                crabList.forEach((crab, crabIndex) => {
                    if (checkCollisionRectRect(pike, crab)) {
                        crabList.splice(crabIndex, 1);
                    }
                });

                bassList.forEach((bass, bassIndex) => {
                    if (checkCollisionRectRect(pike, bass)) {
                        bassList.splice(bassIndex, 1);
                    }
                });
            });

            if (timeSurvived % (10 * 60) === 0) score++;

            // Spawn bubbles
            if (Math.random() < 0.01) {
                bubbles.push(spawnBubble());
            }

            // Update bubbles
            bubbles.forEach((bubble, index) => {
                bubble.y += bubble.speedY;
                if (bubble.y < -bubble.radius) {
                    bubbles.splice(index, 1);
                }
            });

            // Update sunfish
            sunfishList.forEach((sunfish, sunIndex) => {
                const dx = minnow.x - sunfish.x;
                const dy = minnow.y - sunfish.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < difficulty.aggressionRange) {
                    const angle = Math.atan2(dy, dx);
                    sunfish.speedX = Math.cos(angle) * difficulty.aggressionSpeed;
                    sunfish.speedY = Math.sin(angle) * difficulty.aggressionSpeed;
                    sunfish.changeDirection = 30;
                } else {
                    sunfish.speedY = (Math.random() * 0.5 - 0.25) * difficulty.speedMultiplier;
                    sunfish.changeDirection--;
                    if (sunfish.changeDirection <= 0) {
                        sunfish.speedY = (Math.random() * 0.5 - 0.25) * difficulty.speedMultiplier;
                        sunfish.changeDirection = Math.floor(Math.random() * 60) + 60;
                    }
                }

                sunfish.x += sunfish.speedX;
                sunfish.y += sunfish.speedY;

                sunfish.y = Math.max(0, Math.min(canvas.height - 50 - sunfish.height, sunfish.y));

                const isOffScreen = sunfish.x + sunfish.width < 0 || sunfish.x > canvas.width;
                if (isOffScreen) {
                    sunfish.timeOffScreen++;
                    if (sunfish.timeOffScreen > 120) {
                        sunfishList.splice(sunIndex, 1);
                        if (spottedSunfishList.length < maxSpottedSunfish && timeSurvived >= 1800) {
                            spottedSunfishList.push(spawnSpottedSunfish());
                        } else {
                            sunfishList.push(spawnSunfish());
                        }
                    }
                } else {
                    sunfish.timeOffScreen = 0;
                }

                if (checkCollisionCircleRect(minnow, sunfish)) gameOver = true;

                crabList.forEach((crab, crabIndex) => {
                    if (checkCollisionRectRect(sunfish, crab)) {
                        crabList.splice(crabIndex, 1);
                    }
                });
            });

            // Update spotted sunfish
            spottedSunfishList.forEach((sunfish, sunIndex) => {
                const dx = minnow.x - sunfish.x;
                const dy = minnow.y - sunfish.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < difficulty.aggressionRange) {
                    const angle = Math.atan2(dy, dx);
                    sunfish.speedX = Math.cos(angle) * difficulty.aggressionSpeed;
                    sunfish.speedY = Math.sin(angle) * difficulty.aggressionSpeed;
                    sunfish.changeDirection = 30;
                } else {
                    sunfish.speedY = (Math.random() * 0.5 - 0.25) * difficulty.speedMultiplier;
                    sunfish.changeDirection--;
                    if (sunfish.changeDirection <= 0) {
                        sunfish.speedX *= -1;
                        sunfish.speedY = (Math.random() * 0.5 - 0.25) * difficulty.speedMultiplier;
                        sunfish.changeDirection = Math.floor(Math.random() * 60) + 30;
                    }
                }

                sunfish.x += sunfish.speedX;
                sunfish.y += sunfish.speedY;

                sunfish.y = Math.max(0, Math.min(canvas.height - 50 - sunfish.height, sunfish.y));

                const isOffScreen = sunfish.x + sunfish.width < 0 || sunfish.x > canvas.width;
                if (isOffScreen) {
                    sunfish.timeOffScreen++;
                    if (sunfish.timeOffScreen > 120) {
                        spottedSunfishList.splice(sunIndex, 1);
                        if (spottedSunfishList.length < maxSpottedSunfish && timeSurvived >= 1800) {
                            spottedSunfishList.push(spawnSpottedSunfish());
                        } else {
                            sunfishList.push(spawnSunfish());
                        }
                    }
                } else {
                    sunfish.timeOffScreen = 0;
                }

                if (checkCollisionCircleRect(minnow, sunfish)) gameOver = true;

                crabList.forEach((crab, crabIndex) => {
                    if (checkCollisionRectRect(sunfish, crab)) {
                        crabList.splice(crabIndex, 1);
                    }
                });
            });

            // Update gar
            garList.forEach((gar, garIndex) => {
                gar.x += gar.speedX;
                gar.y += gar.speedY;
                gar.changeDirection--;
                if (gar.changeDirection <= 0) {
                    gar.speedY = (Math.random() * 0.4 - 0.2) * difficulty.speedMultiplier;
                    gar.changeDirection = Math.floor(Math.random() * 60) + 60;
                }

                gar.y = Math.max(0, Math.min(canvas.height - 50 - gar.height, gar.y));

                const isOffScreen = gar.x + gar.width < 0 || gar.x > canvas.width;
                if (isOffScreen) {
                    garList.splice(garIndex, 1);
                } else if (checkCollisionCircleRect(minnow, gar)) {
                    gameOver = true;
                }

                sunfishList.forEach((sunfish, sunIndex) => {
                    if (checkCollisionRectRect(gar, sunfish)) {
                        sunfishList.splice(sunIndex, 1);
                    }
                });

                spottedSunfishList.forEach((sunfish, sunIndex) => {
                    if (checkCollisionRectRect(gar, sunfish)) {
                        spottedSunfishList.splice(sunIndex, 1);
                    }
                });

                crabList.forEach((crab, crabIndex) => {
                    if (checkCollisionRectRect(gar, crab)) {
                        crabList.splice(crabIndex, 1);
                    }
                });
            });

            // Update crabs
            crabList.forEach((crab, crabIndex) => {
                crab.x += crab.speedX;

                const isOffScreen = crab.x + crab.width < 0 || crab.x > canvas.width;
                if (isOffScreen) {
                    crabList.splice(crabIndex, 1);
                } else if (checkCollisionCircleRect(minnow, crab)) {
                    const dx = minnow.x - (crab.x + crab.width / 2);
                    const dy = minnow.y - (crab.y + crab.height / 2);
                    const angle = Math.atan2(dy, dx);
                    const bounceSpeed = minnow.speed * 6;
                    const bounceFrames = 10;
                    let frame = 0;
                    function smoothBounce() {
                        if (frame < bounceFrames) {
                            const step = bounceSpeed / bounceFrames;
                            minnow.x += Math.cos(angle) * step;
                            minnow.y += Math.sin(angle) * step;
                            minnow.x = Math.max(minnow.radius, Math.min(canvas.width - minnow.radius, minnow.x));
                            minnow.y = Math.max(minnow.radius, Math.min(canvas.height - 50 - minnow.radius, minnow.y));
                            frame++;
                            requestAnimationFrame(smoothBounce);
                        }
                    }
                    smoothBounce();
                }
            });

            // Update bass
            bassList.forEach((bass, bassIndex) => {
                bass.x += bass.speedX;
                bass.y += bass.speedY;
                bass.changeDirection--;
                if (bass.changeDirection <= 0) {
                    bass.speedY = (Math.random() * 0.6 - 0.3) * difficulty.speedMultiplier;
                    bass.changeDirection = Math.floor(Math.random() * 60) + 60;
                }

                bass.y = Math.max(0, Math.min(canvas.height - 50 - bass.height, bass.y));

                const isOffScreen = bass.x + bass.width < 0 || bass.x > canvas.width;
                if (isOffScreen) {
                    bassList.splice(bassIndex, 1);
                } else if (checkCollisionCircleRect(minnow, bass)) {
                    gameOver = true;
                }

                sunfishList.forEach((sunfish, sunIndex) => {
                    if (checkCollisionRectRect(bass, sunfish)) {
                        sunfishList.splice(sunIndex, 1);
                    }
                });

                spottedSunfishList.forEach((sunfish, sunIndex) => {
                    if (checkCollisionRectRect(bass, sunfish)) {
                        spottedSunfishList.splice(sunIndex, 1);
                    }
                });

                crabList.forEach((crab, crabIndex) => {
                    if (checkCollisionRectRect(bass, crab)) {
                        crabList.splice(crabIndex, 1);
                    }
                });
            });

            if (gameOver && score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw bubbles (background)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            bubbles.forEach(bubble => {
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw sandy floor
            ctx.fillStyle = '#F4A460';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

            // Draw kelp
            ctx.fillStyle = 'green';
            for (let i = 0; i < 5; i++) {
                const x = i * 80 + 20;
                ctx.fillRect(x, canvas.height - 100, 10, 50);
            }

            // Draw minnow
            ctx.save();
            if (joystickX < 0) {
                ctx.scale(-1, 1);
                ctx.translate(-canvas.width, 0);
                minnow.x = canvas.width - minnow.x;
            }
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.arc(minnow.x, minnow.y, minnow.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(minnow.x + 4, minnow.y - 2, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(minnow.x + 4, minnow.y - 2, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.moveTo(minnow.x - minnow.radius, minnow.y);
            ctx.lineTo(minnow.x - minnow.radius - 5, minnow.y - 5);
            ctx.lineTo(minnow.x - minnow.radius - 5, minnow.y + 5);
            ctx.closePath();
            ctx.fill();
            if (joystickX < 0) minnow.x = canvas.width - minnow.x;
            ctx.restore();

            // Draw sunfish
            sunfishList.forEach(sunfish => {
                ctx.save();
                if (sunfish.speedX < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);
                    sunfish.x = canvas.width - sunfish.x - sunfish.width;
                }
                ctx.fillStyle = 'orange';
                ctx.fillRect(sunfish.x, sunfish.y, sunfish.width, sunfish.height);
                ctx.beginPath();
                ctx.moveTo(sunfish.x + sunfish.width / 2, sunfish.y);
                ctx.lineTo(sunfish.x + sunfish.width / 2 - 5, sunfish.y - 5);
                ctx.lineTo(sunfish.x + sunfish.width / 2 + 5, sunfish.y - 5);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(sunfish.x + sunfish.width / 2, sunfish.y + sunfish.height);
                ctx.lineTo(sunfish.x + sunfish.width / 2 - 5, sunfish.y + sunfish.height + 5);
                ctx.lineTo(sunfish.x + sunfish.width / 2 + 5, sunfish.y + sunfish.height + 5);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(sunfish.x + sunfish.width - 4, sunfish.y + 4, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(sunfish.x + sunfish.width - 4, sunfish.y + 4, 1, 0, Math.PI * 2);
                ctx.fill();
                if (sunfish.speedX < 0) sunfish.x = canvas.width - sunfish.x - sunfish.width;
                ctx.restore();
            });

            // Draw spotted sunfish
            spottedSunfishList.forEach(sunfish => {
                ctx.save();
                if (sunfish.speedX < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);
                    sunfish.x = canvas.width - sunfish.x - sunfish.width;
                }
                ctx.fillStyle = '#4682B4';
                ctx.fillRect(sunfish.x, sunfish.y, sunfish.width, sunfish.height);
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(sunfish.x + 4, sunfish.y + 4, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(sunfish.x + 16, sunfish.y + 16, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(sunfish.x + 10, sunfish.y + 8, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#4682B4';
                ctx.beginPath();
                ctx.moveTo(sunfish.x + sunfish.width / 2, sunfish.y);
                ctx.lineTo(sunfish.x + sunfish.width / 2 - 5, sunfish.y - 5);
                ctx.lineTo(sunfish.x + sunfish.width / 2 + 5, sunfish.y - 5);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(sunfish.x + sunfish.width / 2, sunfish.y + sunfish.height);
                ctx.lineTo(sunfish.x + sunfish.width / 2 - 5, sunfish.y + sunfish.height + 5);
                ctx.lineTo(sunfish.x + sunfish.width / 2 + 5, sunfish.y + sunfish.height + 5);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(sunfish.x + sunfish.width - 4, sunfish.y + 4, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(sunfish.x + sunfish.width - 4, sunfish.y + 4, 1, 0, Math.PI * 2);
                ctx.fill();
                if (sunfish.speedX < 0) sunfish.x = canvas.width - sunfish.x - sunfish.width;
                ctx.restore();
            });

            // Draw gar
            garList.forEach(gar => {
                ctx.save();
                if (gar.speedX < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);
                    gar.x = canvas.width - gar.x - gar.width;
                }
                ctx.fillStyle = '#4A2F1A';
                ctx.fillRect(gar.x, gar.y, gar.width, gar.height / 2);
                ctx.fillStyle = '#8B552F';
                ctx.fillRect(gar.x, gar.y + gar.height / 2, gar.width, gar.height / 2);
                ctx.fillStyle = '#4A2F1A';
                ctx.beginPath();
                ctx.moveTo(gar.x + gar.width / 2 - 5, gar.y);
                ctx.lineTo(gar.x + gar.width / 2, gar.y - 15);
                ctx.lineTo(gar.x + gar.width / 2 + 5, gar.y);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#8B552F';
                ctx.beginPath();
                ctx.moveTo(gar.x, gar.y + gar.height / 2);
                ctx.lineTo(gar.x - 10, gar.y);
                ctx.lineTo(gar.x - 10, gar.y + gar.height);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(gar.x + gar.width - 10, gar.y + gar.height / 2, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(gar.x + gar.width - 10, gar.y + gar.height / 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(gar.x + gar.width, gar.y + 2);
                ctx.lineTo(gar.x + gar.width + 5, gar.y + 4);
                ctx.lineTo(gar.x + gar.width, gar.y + 6);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(gar.x + gar.width, gar.y + gar.height - 2);
                ctx.lineTo(gar.x + gar.width + 5, gar.y + gar.height - 4);
                ctx.lineTo(gar.x + gar.width, gar.y + gar.height - 6);
                ctx.closePath();
                ctx.fill();
                if (gar.speedX < 0) gar.x = canvas.width - gar.x - gar.width;
                ctx.restore();
            });

            // Draw crabs
            crabList.forEach(crab => {
                ctx.save();
                if (crab.speedX < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);
                    crab.x = canvas.width - crab.x - crab.width;
                }
                ctx.fillStyle = 'red';
                ctx.fillRect(crab.x, crab.y, crab.width, crab.height);
                ctx.fillStyle = 'black';
                ctx.fillRect(crab.x + 2, crab.y - 2, 2, 2);
                ctx.fillRect(crab.x + crab.width - 4, crab.y - 2, 2, 2);
                ctx.fillStyle = 'red';
                ctx.fillRect(crab.x - 5, crab.y + 2, 5, crab.height - 4);
                ctx.fillRect(crab.x + crab.width, crab.y + 2, 5, crab.height - 4);
                if (crab.speedX < 0) crab.x = canvas.width - crab.x - crab.width;
                ctx.restore();
            });

            // Draw bass
            bassList.forEach(bass => {
                ctx.save();
                if (bass.speedX < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);
                    bass.x = canvas.width - bass.x - bass.width;
                }
                ctx.fillStyle = '#2F4F2F';
                ctx.fillRect(bass.x, bass.y, bass.width, bass.height / 2);
                ctx.fillStyle = '#90EE90';
                ctx.fillRect(bass.x, bass.y + bass.height / 2, bass.width, bass.height / 2);
                ctx.fillStyle = '#2F4F2F';
                ctx.beginPath();
                ctx.moveTo(bass.x + bass.width / 2, bass.y);
                ctx.lineTo(bass.x + bass.width / 2 - 8, bass.y - 10);
                ctx.lineTo(bass.x + bass.width / 2 + 8, bass.y - 10);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#90EE90';
                ctx.beginPath();
                ctx.moveTo(bass.x, bass.y + bass.height / 2);
                ctx.lineTo(bass.x - 10, bass.y + bass.height / 2 - 10);
                ctx.lineTo(bass.x - 10, bass.y + bass.height / 2 + 10);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(bass.x + bass.width - 6, bass.y + 6, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(bass.x + bass.width - 6, bass.y + 6, 1.5, 0, Math.PI * 2);
                ctx.fill();
                if (bass.speedX < 0) bass.x = canvas.width - bass.x - bass.width;
                ctx.restore();
            });

            // Draw pike
            pikeList.forEach(pike => {
                if (pike.spawnDelay > 0) return;
                
                ctx.save();
                if (pike.speedX < 0) {
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);
                    pike.x = canvas.width - pike.x - pike.width;
                }
                ctx.fillStyle = '#3C4A45';
                ctx.fillRect(pike.x, pike.y, pike.width, pike.height / 2);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(pike.x, pike.y + pike.height / 2, pike.width, pike.height / 2);
                ctx.fillStyle = '#3C4A45';
                ctx.beginPath();
                ctx.moveTo(pike.x + pike.width / 2, pike.y);
                ctx.lineTo(pike.x + pike.width / 2 - 12, pike.y - 18);
                ctx.lineTo(pike.x + pike.width / 2 + 12, pike.y - 18);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.moveTo(pike.x, pike.y + pike.height / 2);
                ctx.lineTo(pike.x - 20, pike.y + pike.height / 2 - 20);
                ctx.lineTo(pike.x - 20, pike.y + pike.height / 2 + 20);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(pike.x + pike.width - 8, pike.y + 8, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(pike.x + pike.width - 8, pike.y + 8, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(pike.x + pike.width, pike.y + pike.height / 4);
                ctx.lineTo(pike.x + pike.width + 8, pike.y + pike.height / 4 + 8);
                ctx.lineTo(pike.x + pike.width, pike.y + pike.height / 4 + 16);
                ctx.closePath();
                ctx.fill();
                if (pike.speedX < 0) pike.x = canvas.width - pike.x - pike.width;
                ctx.restore();
            });

            // Draw warning triangle
            if (warningActive && warningBlink < 10) {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.moveTo(warningX, canvas.height / 2 - 15);
                ctx.lineTo(warningX - 15, canvas.height / 2 + 15);
                ctx.lineTo(warningX + 15, canvas.height / 2 + 15);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw score
            if (gameStarted) {
                ctx.fillStyle = 'black';
                ctx.font = '16px Arial';
                ctx.fillText(`Score: ${score}`, 10, 20);
            }

            // Game over text
            if (gameOver) {
                ctx.fillStyle = 'red';
                ctx.font = '20px Arial';
                ctx.fillText('Game Over! Tap to restart', 50, canvas.height/2 - 20);
                ctx.fillText(`Score: ${score}`, 50, canvas.height/2 + 10);
                ctx.fillText(`High Score: ${highScore}`, 50, canvas.height/2 + 40);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start game
        startButton.addEventListener('click', () => {
            gameStarted = true;
            startScreen.style.display = 'none';
            joystick.style.display = 'block';
        });

        // Restart game
        canvas.addEventListener('touchstart', (e) => {
            if (gameOver) {
                gameOver = false;
                minnow.x = 160;
                minnow.y = 240;
                sunfishList = [];
                spottedSunfishList = [];
                garList = [];
                crabList = [];
                bassList = [];
                pikeList = [];
                bubbles = [];
                timeSurvived = 0;
                score = 0;
                gameStarted = true;
                joystick.style.display = 'block';
            }
        });

        gameLoop();
    </script>
</body>
</html>